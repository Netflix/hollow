
<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <link rel="shortcut icon" href="../assets/images/favicon.png">
      
      <meta name="generator" content="mkdocs-0.16.3, mkdocs-material-1.10.1">
    
    
      
        <title>Data Modeling - Hollow (Netflix OSS)</title>
      
    
    
      <script src="../assets/javascripts/modernizr-e826f8942a.js"></script>
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application-a20f419c8e.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-23f75ab9c7.palette.css">
      
    
    
      
        
        
        
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
    
    
  </head>
  
  
  
  
    <body data-md-color-primary="red" data-md-color-accent="brown">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="search">
    <label class="md-overlay" data-md-component="overlay" for="drawer"></label>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href=".." title="Hollow (Netflix OSS)" class="md-header-nav__button md-logo">
          
            <i class="md-icon md-icon--home"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <span class="md-flex__ellipsis md-header-nav__title">
          
            
              
            
            Data Modeling
          
        </span>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="search"></label>
  <div class="md-search__inner">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" required placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query">
      <label class="md-icon md-search__icon" for="search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset">&#xE5CD;</button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result" data-md-lang-search="" data-md-lang-tokenizer="[\s\-]+">
          <div class="md-search-result__meta" data-md-lang-result-none="No matching documents" data-md-lang-result-one="1 matching document" data-md-lang-result-other="# matching documents">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  


  <a href="https://github.com/Netflix/hollow" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="drawer">
    <div class="md-nav__button md-logo">
      
        <i class="md-icon md-icon--home"></i>
      
    </div>
    Hollow (Netflix OSS)
  </label>
  
    <div class="md-nav__source">
      


  


  <a href="https://github.com/Netflix/hollow" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Introduction" class="md-nav__link">
      Introduction
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../quick-start/" title="Quick Start" class="md-nav__link">
      Quick Start
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../getting-started/" title="Getting Started" class="md-nav__link">
      Getting Started
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../indexing-querying/" title="Indexing/Querying" class="md-nav__link">
      Indexing/Querying
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../producer-consumer/" title="Producers and Consumers" class="md-nav__link">
      Producers and Consumers
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../tooling/" title="Tooling" class="md-nav__link">
      Tooling
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="toc">
    
      
    
    
    <a href="./" title="Data Modeling" class="md-nav__link md-nav__link--active">
      Data Modeling
    </a>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../diving-deeper/" title="Diving Deeper" class="md-nav__link">
      Diving Deeper
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../interacting-with-a-dataset/" title="Interacting with a Hollow Dataset" class="md-nav__link">
      Interacting with a Hollow Dataset
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../data-ingestion/" title="Data Ingestion" class="md-nav__link">
      Data Ingestion
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../advanced-topics/" title="Advanced Topics" class="md-nav__link">
      Advanced Topics
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../glossary/" title="Glossary" class="md-nav__link">
      Glossary
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../community/" title="Community" class="md-nav__link">
      Community
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../acknowledgements/" title="Acknowledgements" class="md-nav__link">
      Acknowledgements
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../license/" title="License" class="md-nav__link">
      License
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/Netflix/hollow/edit/master/docs/data-modeling.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="schemas">Schemas</h1>
<p>A Hollow data model is a set of schemas, which are usually defined by the POJOs used on the producer to <a href="../getting-started/#producing-a-data-snapshot">populate the data</a>.  This section will use POJOs as examples, but there are other ways to define schemas -- for example you could ingest a text file and use the <a href="../advanced-topics/#schema-parser">schema parser</a>.</p>
<div class="admonition note">
<p class="admonition-title">Schemas Define the Data Model</p>
<p>A hollow dataset is comprised of one or more data <em>types</em>.  The <em>data model</em> for a dataset is defined by the schemas describing those types.</p>
</div>
<h1 id="object-schemas">Object Schemas</h1>
<p>Each POJO class you define will result in an <code>Object</code> schema, which is a fixed set of strongly typed fields.  The fields will be based on the member variables in the class.  For example, the class <code>Movie</code> will define an <code>Object</code> schema with three fields:</p>
<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Movie</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">movieId</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">title</span><span class="o">;</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Actor</span><span class="o">&gt;</span> <span class="n">actors</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>Each schema has a <em>type name</em>.  The name of the type will default to the simple name of your POJO -- in this case <code>Movie</code>.  </p>
<p>Each schema field has a <em>field name</em>, which will default to the same name as the field in the POJO -- in this case <code>movieId</code>, <code>title</code>, and <code>actors</code>.  Each field also has a <em>field type</em>, which is in this case <code>INT</code>, <code>REFERENCE</code>, and <code>REFERENCE</code>, respectively.  Each <code>REFERENCE</code> field also indicates the <em>referenced type</em>, which for our reference fields above default to <code>String</code> and <code>SetOfActor</code>.</p>
<p>The possible field types are:</p>
<ul>
<li><code>INT</code>: An integer value up to 32-bits</li>
<li><code>LONG</code>: An integer value up to 64-bits</li>
<li><code>FLOAT</code>: A 32-bit floating-point value</li>
<li><code>DOUBLE</code>: A 64-bit floating-point value</li>
<li><code>BOOLEAN</code>: <code>true</code> or <code>false</code></li>
<li><code>STRING</code>: An array of characters</li>
<li><code>BYTES</code>: An array of bytes</li>
<li><code>REFERENCE</code>: A reference to another specific type.  The referenced type must be defined by the schema.</li>
</ul>
<p>Notice that since the reference type is <strong>defined by the schema</strong>, data models must be strongly typed.  Each reference in your data model must point to a specific concrete implementation.  References to interfaces, abstract classes, or <code>java.lang.Object</code> are not supported.</p>
<h2 id="primary-keys">Primary Keys</h2>
<p><code>Object</code> schemas may specify a primary key.  This is accomplished by using the <code>@HollowPrimaryKey</code> annotation and specifying the fields.</p>
<div class="codehilite"><pre><span></span><span class="nd">@HollowPrimaryKey</span><span class="o">(</span><span class="n">fields</span><span class="o">={</span><span class="s">&quot;movieId&quot;</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Movie</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">movieId</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">title</span><span class="o">;</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Actor</span><span class="o">&gt;</span> <span class="n">actors</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>When defined in the schema, primary keys are a part of your data model and drive useful functionality and default configuration in the <a href="../tooling/#hollow-explorer">hollow explorer</a>, <a href="../tooling/#history-tool">hollow history</a>, and <a href="../tooling/#diff-tool">diff ui</a>.  They also provide a shortcut when creating a <a href="../indexing-querying/#default-primary-keys">primary key index</a>.</p>
<p>Primary keys defined in the schema follow the same convention as primary keys defined for indexes.  They consist of one or more <a href="../indexing-querying/#field-paths">field paths</a>, which will auto-expand if they terminate in a <code>REFERENCE</code> field.</p>
<h2 id="inlined-vs-referenced-fields">Inlined vs Referenced Fields</h2>
<p>We can <em>inline</em> some fields in our POJOs so that they are no longer <code>REFERENCE</code> fields, but instead encode their data directly in each record:</p>
<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Movie</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">movieId</span><span class="o">;</span>
    <span class="nd">@HollowInline</span> <span class="n">String</span> <span class="n">title</span><span class="o">;</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Actor</span><span class="o">&gt;</span> <span class="n">actors</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>In the above example, our fields are now of type <code>INT</code>, <code>STRING</code>, and <code>REFERENCE</code>.</p>
<p>While modeling data, we choose whether or not to inline a field for efficiency.  Consider the following type:</p>
<div class="codehilite"><pre><span></span>public class Award {
    String awardName;
    long movieId;
    long actorId;
}
</pre></div>


<p>In this case, imagine <code>awardName</code> is something like “Best Supporting Actress”.  Over the years, many such awards will be given, so we’ll have a lot of records which share that value.  If we use an <em>inlined</em> <code>STRING</code> field, then the value "Best Supporting Actress" will be repeated for every such award record.  However, if we reference a separate record type, all such awards will reference the same child record with that value.  If the <code>awardName</code> values have a lot of repetition, then this can result in a significant savings.</p>
<div class="admonition hint">
<p class="admonition-title">Deduplication</p>
<p>Record deduplication happens automatically at the <em>record</em> granularity in Hollow.  Try to model your data such that when there is a lot of repetition in records, the repetitive fields are encapsulated into their own types.</p>
</div>
<p>To consider the opposite case, let’s examine the following <code>Actor</code> type:</p>
<div class="codehilite"><pre><span></span>public class Actor {
    long id;
    @HollowInline String actorName;
}
</pre></div>


<p>The <code>actorName</code> is unlikely to be repeated often.  In this case, if we reference a separate record type, we have to retain roughly the same number of unique character strings <strong>plus</strong> we need to retain references to those records.  In this case, we end up saving space by using an inlined <code>STRING</code> field instead of a reference to a separate type.</p>
<div class="admonition warning">
<p class="admonition-title">Reference Costs</p>
<p>A <code>REFERENCE</code> field isn't free, and therefore we shouldn't necessarily try to encapsulate fields inside their own record types where we won't benefit from deduplication.  These fields should instead be <em>inlined</em>.</p>
</div>
<p>We refer to fields which are defined with native Hollow types as <em>inlined</em> fields, and fields which are defined as references to types with a single field as <em>referenced</em> fields.</p>
<h2 id="namespaced-record-type-names">Namespaced Record Type Names</h2>
<p>In order to be very efficient, referenced types sometimes should be <em>namespaced</em> so that fields with like values may reference the same <em>record type</em>, but reference fields of the same <em>primitive type</em> elsewhere in the data model use different <em>record types</em>.  For example, consider our <code>Award</code> type again, but this time, we’ll reference a type called <code>AwardName</code>, instead of <code>String</code>.  We can explicitly name the <em>type</em> of a field with the <code>@HollowTypeName</code> annotation:</p>
<div class="codehilite"><pre><span></span>public class Award {
    @HollowTypeName(name=&quot;AwardName&quot;)
    String awardName;
    long movieId;
    long actorId;
}
</pre></div>


<p>Other types in our data model which reference award names can reuse the <code>AwardName</code> type.  Other referenced string fields in our data model, which are unrelated to award names, should use different types corresponding to the semantics of their values.  </p>
<p>Namespacing fields saves space because references to types with a lower cardinality use fewer bits than references to types with a higher cardinality.  The reason for this can be gleaned from the <a href="../advanced-topics/#in-memory-data-layout">In-Memory Data Layout</a> topic underneath the <a href="../advanced-topics/">Advanced Topics</a> section.</p>
<p>Namespacing fields is also useful if some consumers don't need the contents of a specific referenced field.  If a type is namespaced, it can be selectively <a href="../tooling/#filtering">filtered</a>, whereas if it is grouped with other fields which <em>are</em> needed by all consumers, then it cannot be selected for filtering.</p>
<div class="admonition note">
<p class="admonition-title">Namespacing Reduces Reference Costs</p>
<p>Using an appropriately <em>namespaced</em> type reduces the heap footprint cost of <code>REFERENCE</code> fields.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Changing default <em>type names</em></p>
<p>The <code>@HollowTypeName</code> annotation can also be used at the class level to select a default type name for a class other than its simple name.</p>
</div>
<h2 id="grouping-associated-fields">Grouping Associated Fields</h2>
<p>Referencing fields can save space because the same field values do not have to be repeated for every record in which they occur.  Similarly, we can <em>group</em> fields which have covarying values, and pull these out from larger objects as their own types.  For example, imagine we started with a <code>Movie</code> type which included the following fields:</p>
<div class="codehilite"><pre><span></span>public class Movie {
    long id;
    String title;
    String maturityRating;
    String advisories;
}
</pre></div>


<p>We might notice that the <code>maturityRating</code> and <code>advisories</code> fields vary together, and are often the repeated across many <code>Movie</code> records.  We can pull out a separate type for these fields:</p>
<div class="codehilite"><pre><span></span>public class Movie {
    long id;
    String title;
    MaturityRating maturityRating;
}

public class MaturityRating {
    string rating;
    string advisories;
}
</pre></div>


<p>We could have referenced these fields separately.  If we had done so, each <code>Movie</code> record, of which there are probably many, would have had to contain two separate references for these fields.  Instead, by recognizing that these fields were associated and pulling them together, space is saved because each <code>Movie</code> record now only contains one reference for this data.</p>
<h1 id="list-schemas">List Schemas</h1>
<p>You can define <code>List</code> schemas by adding a member variable of type <code>List</code> in your data model.  For example:</p>
<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Movie</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">title</span><span class="o">;</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Award</span><span class="o">&gt;</span> <span class="n">awardsReceived</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>The <code>List</code> must explicitly define its parameterized element type.  The default <em>type name</em> of the above <code>List</code> schema will be <code>ListOfAward</code>.  </p>
<p>A <code>List</code> schema indicates a record type which is an ordered collection of <code>REFERENCE</code> fields.  Each record will have a variable number of references.  The referenced type must be defined by the schema, and all references in all records will encode only the <em>ordinals</em> of the referenced records as the values for these references.</p>
<h1 id="set-schemas">Set Schemas</h1>
<p>You can define <code>Set</code> schemas by adding a member variable of type <code>Set</code> in your data model.  The <code>Set</code> must explicitly define its parameterized element type.  For example:</p>
<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Movie</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">title</span><span class="o">;</span>

    <span class="nd">@HollowHashKey</span><span class="o">(</span><span class="n">fields</span><span class="o">={</span><span class="s">&quot;firstName&quot;</span><span class="o">,</span> <span class="s">&quot;lastName&quot;</span><span class="o">})</span> <span class="c1">/// hash key is optional</span>
    <span class="n">Set</span><span class="o">&lt;</span><span class="n">Actor</span><span class="o">&gt;</span> <span class="n">cast</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>A <code>Set</code> schema indicates a record type which is an unordered collection of <code>REFERENCE</code> fields.  Each record will have a variable number of references, and the referenced type must be defined by the schema.  Within a single set record, each reference must be unique.  </p>
<p>References in <code>Set</code> records can be hashed by some specific element fields for O(1) retrieval.  In order to enable this feature, a <code>Set</code> schema will define an optional <em>hash key</em>, which defines how its elements are hashed/indexed.</p>
<h1 id="map-schemas">Map Schemas</h1>
<p>You can define <code>Map</code> schemas by adding a member variable of type <code>Map</code> in your data model.  The <code>Map</code> must explicitly define it parameterized key and values types.  For example:</p>
<div class="codehilite"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Movie</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="n">String</span> <span class="n">title</span><span class="o">;</span>

    <span class="nd">@HollowHashKey</span><span class="o">(</span><span class="n">fields</span><span class="o">=</span><span class="s">&quot;actorId&quot;</span><span class="o">)</span> <span class="c1">/// hash key is optional</span>
    <span class="n">Map</span><span class="o">&lt;</span><span class="n">Actor</span><span class="o">,</span> <span class="n">Role</span><span class="o">&gt;</span> <span class="n">cast</span><span class="o">;</span>
<span class="o">}</span>
</pre></div>


<p>A <code>Map</code> schema indicates a record type which is an unordered collection of pairs of <code>REFERENCE</code> fields, used to represent a key/value mapping.  Each record will have a variable number of key/value pairs.  Both the key reference type and the value reference type must be defined by the schema.  The key reference type does not have to be the same as the value reference type.  Within a single map record, each key reference must be unique.  </p>
<p>Entries in <code>Map</code> records can be hashed by some specific key fields for O(1) retrieval of the keys, values, and/or entries.  In order to enable this feature, a <code>Map</code> schema will define an optional <em>hash key</em>, which defines how its entries are hashed/indexed.</p>
<h1 id="hash-keys">Hash Keys</h1>
<p>Each <code>Map</code> and <code>Set</code> schema may optionally define a <em>hash key</em>.  A <em>hash key</em> specifies one or more user-defined fields used to hash entries into the collection.  When a hash key is defined on a <code>Set</code>, each set record becomes like a primary key index; records in the set can be efficiently retrieved by matching the specified <em>hash key</em> fields.  Similarly, when a hash key is defined on a <code>Map</code>, each map record becomes like an index over the keys in the key/value pairs contained in the map record.</p>
<p>See <a href="../indexing-querying/#hash-keys">Hash Keys</a> for a detailed discussion of hash keys.</p>
<h3 id="circular-references">Circular References</h3>
<p>Circular references are not allowed in Hollow.  A type may not reference itself, either directly or transitively.</p>
<h3 id="object-memory-layout">Object Memory Layout</h3>
<p>On consumers, <code>INT</code> and <code>LONG</code> fields are each represented by a number of bits exactly sufficient to represent the maximum value for the field across all records.  <code>FLOAT</code>, <code>DOUBLE</code>, and <code>BOOLEAN</code> fields are represented by 32, 64, and 2 bits, respectively.  <code>STRING</code> and <code>BYTES</code> fields use a variable number of bytes for each record.  <code>REFERENCE</code> fields encode the <em>ordinal</em> of referenced records, and are represented by a number of bits exactly sufficient to encode the maximum ordinal of the referenced type.  See <a href="../advanced-topics/#in-memory-data-layout">In-memory Data Layout</a> for more details.</p>
<div class="admonition hint">
<p class="admonition-title">Avoid Outlier Values</p>
<p>Try to model your data such that there aren't any outlier values for <code>INT</code> and <code>LONG</code> fields.  Also, avoid <code>FLOAT</code> and <code>DOUBLE</code> fields where possible, since these field types are relatively expensive.</p>
</div>
<h1 id="maintaining-backwards-compatibility">Maintaining Backwards Compatibility</h1>
<p>A data model will evolve over time.  The following operations will not impact the interoperability between existing clients and new data:</p>
<ul>
<li>Adding a new type</li>
<li>Removing an existing type</li>
<li>Adding a new field to an existing type</li>
<li>Removing an existing field from an existing type.</li>
</ul>
<p>When adding new fields or types, existing generated client APIs will ignore the new fields, and all of the fields which existed at the time of API generation will still be visible using the same methods.  When removing fields, existing generated client APIs will see null values if the methods corresponding to the removed fields are called.  When removing types, existing generated client APIs will see removed types as having no records.</p>
<p>It is not backwards compatible to change the type of an existing field.  The client behavior when calling a method corresponding to a field with a changed type is undefined.</p>
<p>It is not backwards compatible to change the primary key or hash key for any type.</p>
<p>Beyond the specification of Hollow itself, backwards compatibility often has a lot to do with the use case and semantics of the data. Hollow will always behave in the stated way for evolving data models, but it’s possible that consumers require a field which starts returning null once it gets removed.  For this reason, additional caution should be exercised when removing types and fields.</p>
<div class="admonition hint">
<p class="admonition-title">Backwards-incompatible data remodeling</p>
<p>Every so often, it may be required or desirable to make changes to the data model which are incompatible with prior versions.  In this case, an older producer, which produces the older data model, should run in parallel with the newer producer, producing the newer incompatible data model.  Each producer should write its blobs to a different <a href="../producer-consumer/#blob-namespaces">namespace</a>, so that older consumers can read from the old data model, and newer consumers can read from the newer data model.  Once all consumers are upgraded and reading from the newer data model, the older producer can be decommissioned.</p>
</div>
                
                  
                
              
              
                
              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../tooling/" title="Tooling" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Tooling
              </span>
            </div>
          </a>
        
        
          <a href="../diving-deeper/" title="Diving Deeper" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Diving Deeper
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="http://www.mkdocs.org" title="MkDocs">MkDocs</a>
        and
        <a href="http://squidfunk.github.io/mkdocs-material/" title="Material for MkDocs">
          Material for MkDocs</a>
      </div>
      
        
  <div class="md-footer-social">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    
      <a href="https://github.com/Netflix/hollow" class="md-footer-social__link fa fa-github"></a>
    
      <a href="https://gitter.im/Netflix/hollow" class="md-footer-social__link fa fa-gitter"></a>
    
  </div>

      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application-f3ab9e5ff8.js"></script>
      
      
      <script>app.initialize({url:{base:".."}})</script>
      
    
    
      
    
  </body>
</html>
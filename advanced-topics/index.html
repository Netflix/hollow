
<!DOCTYPE html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <link rel="shortcut icon" href="../assets/images/favicon.png">
      
      <meta name="generator" content="mkdocs-0.16.3, mkdocs-material-1.10.1">
    
    
      
        <title>Advanced Topics - Hollow (Netflix OSS)</title>
      
    
    
      <script src="../assets/javascripts/modernizr-e826f8942a.js"></script>
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application-a20f419c8e.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-23f75ab9c7.palette.css">
      
    
    
      
        
        
        
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
      <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    
    
    
  </head>
  
  
  
  
    <body data-md-color-primary="red" data-md-color-accent="brown">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="drawer">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="search">
    <label class="md-overlay" data-md-component="overlay" for="drawer"></label>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href=".." title="Hollow (Netflix OSS)" class="md-header-nav__button md-logo">
          
            <i class="md-icon md-icon--home"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <span class="md-flex__ellipsis md-header-nav__title">
          
            
              
            
            Advanced Topics
          
        </span>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="search"></label>
  <div class="md-search__inner">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" required placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query">
      <label class="md-icon md-search__icon" for="search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset">&#xE5CD;</button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result" data-md-lang-search="" data-md-lang-tokenizer="[\s\-]+">
          <div class="md-search-result__meta" data-md-lang-result-none="No matching documents" data-md-lang-result-one="1 matching document" data-md-lang-result-other="# matching documents">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  


  <a href="https://github.com/Netflix/hollow" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
      
      <main class="md-main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="drawer">
    <div class="md-nav__button md-logo">
      
        <i class="md-icon md-icon--home"></i>
      
    </div>
    Hollow (Netflix OSS)
  </label>
  
    <div class="md-nav__source">
      


  


  <a href="https://github.com/Netflix/hollow" title="Go to repository" class="md-source" data-md-source="github">
    
      <div class="md-source__icon">
        <svg viewBox="0 0 24 24" width="24" height="24">
          <use xlink:href="#github" width="24" height="24"></use>
        </svg>
      </div>
    
    <div class="md-source__repository">
      GitHub
    </div>
  </a>

    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Introduction" class="md-nav__link">
      Introduction
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../quick-start/" title="Quick Start" class="md-nav__link">
      Quick Start
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../getting-started/" title="Getting Started" class="md-nav__link">
      Getting Started
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../indexing-querying/" title="Indexing/Querying" class="md-nav__link">
      Indexing/Querying
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../producer-consumer/" title="Producers and Consumers" class="md-nav__link">
      Producers and Consumers
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../tooling/" title="Tooling" class="md-nav__link">
      Tooling
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../data-modeling/" title="Data Modeling" class="md-nav__link">
      Data Modeling
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../diving-deeper/" title="Diving Deeper" class="md-nav__link">
      Diving Deeper
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../interacting-with-a-dataset/" title="Interacting with a Hollow Dataset" class="md-nav__link">
      Interacting with a Hollow Dataset
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../data-ingestion/" title="Data Ingestion" class="md-nav__link">
      Data Ingestion
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="toc">
    
      
    
    
    <a href="./" title="Advanced Topics" class="md-nav__link md-nav__link--active">
      Advanced Topics
    </a>
    
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../glossary/" title="Glossary" class="md-nav__link">
      Glossary
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../community/" title="Community" class="md-nav__link">
      Community
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../acknowledgements/" title="Acknowledgements" class="md-nav__link">
      Acknowledgements
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../license/" title="License" class="md-nav__link">
      License
    </a>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/Netflix/hollow/edit/master/docs/advanced-topics.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="schema-parser">Schema Parser</h1>
<p>Hollow schemas can be serialized as Java Strings.  Calling <code>toString()</code> on a <code>HollowSchema</code> will produce a human-readable representation of the schema.  The following shows the String representations of all of the schemas from a <code>Movie</code>/<code>Actor</code> example data model:</p>
<div class="codehilite"><pre><span></span>Movie @PrimaryKey(id) {
    long id;
    int releaseYear;
    string title;
    SetOfActor actors;
}

SetOfActor Set&lt;Actor&gt; @HashKey(firstname, surname);

Actor {
    long id;
    String firstname;
    String surname;
}

String {
    string value;
}
</pre></div>


<p>These representations can be parsed using the <code>HollowSchemaParser</code>, and in turn can be used to initialize the state of a <code>HollowWriteStateEngine</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">String</span> <span class="n">allSchemas</span> <span class="o">=</span> <span class="c1">/// a String containing all schemas</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">HollowSchema</span><span class="o">&gt;</span> <span class="n">schemas</span> <span class="o">=</span> 
             <span class="n">HollowSchemaParser</span><span class="o">.</span><span class="na">parseCollectionOfSchemas</span><span class="o">(</span><span class="n">allSchemas</span><span class="o">);</span>

<span class="n">HollowWriteStateEngine</span> <span class="n">initializedWriteEngine</span> <span class="o">=</span> 
             <span class="n">HollowWriteStateCreator</span><span class="o">.</span><span class="na">createWithSchemas</span><span class="o">(</span><span class="n">schemas</span><span class="o">);</span>
</pre></div>


<div class="admonition hint">
<p class="admonition-title">Guiding Data Ingestion with a Data Model</p>
<p>For a generic data ingestion mechanism, loading the schemas from a text representation comes in handy.  For example, the <a href="../data-ingestion/#json-to-hollow-adapter">JSON to Hollow adapter</a> requires a <code>HollowWriteStateEngine</code> which is preinitialized with a data model.  The data model can be configured in a text file, and loaded with the <code>HollowSchemaParser</code>.</p>
</div>
<p>Object schema definitions take the following form:</p>
<div class="codehilite"><pre><span></span>ObjectTypeName @PrimaryKey(fieldName1, fieldNameN) {
   FieldType1 fieldName1;
   FieldType2 fieldName2;
   ...
   FieldTypeN fieldNameN;
}
</pre></div>


<p>The primary key definition is optional and should be omitted if no primary key should be defined for a type.</p>
<p>Object schemas may define any of the following field types: <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>boolean</code>, <code>string</code>, <code>bytes</code>.  If a field has a type other than these, the field will be interpreted as a <code>REFERENCE</code> to another type of that name.</p>
<div class="admonition warning">
<p class="admonition-title">Lowercase Field Type Declarations</p>
<p>Note that the declarations for each of the inline field types are all lowercase (including <code>string</code>).  An uppercase letter in any of these types will be interpreted as a <code>REFERENCE</code> field to a separate type.</p>
</div>
<p><code>List</code>, <code>Set</code>, and <code>Map</code> types use the following notation:</p>
<ul>
<li><code>ListTypeName List&lt;ElementTypeName&gt;;</code></li>
<li><code>SetTypeName Set&lt;ElementTypeName&gt; @HashKey(elementFieldOne, elementFieldTwo);</code></li>
<li><code>MapTypeName Map&lt;KeyTypeName, ValueTypeName&gt; @HashKey(keyFieldOne, keyFieldTwo);</code></li>
</ul>
<p><code>Set</code> and <code>Map</code> types may optionally define a <a href="../indexing-querying/#hash-keys">hash key</a>.  The hash key definition should be omitted if no hash key should be defined for a type.</p>
<p>Elements, keys, and values in collection record types cannot be inlined.  Whitespace is unimportant when parsing schema definitions.</p>
<h1 id="low-level-input-api">Low Level Input API</h1>
<p>Although Hollow includes a few ready-made data ingestion utilities, other data ingestion utilities can be created.  Adding data into Hollow starts with a <code>HollowWriteStateEngine</code>.  We need to initialize a type state for each schema in our data model:</p>
<div class="codehilite"><pre><span></span><span class="n">HollowWriteStateEngine</span> <span class="n">writeEngine</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowWriteStateEngine</span><span class="o">();</span>

<span class="n">HollowObjectSchema</span> <span class="n">movieSchema</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowObjectSchema</span><span class="o">(</span><span class="s">&quot;Movie&quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
<span class="n">movieSchema</span><span class="o">.</span><span class="na">addField</span><span class="o">(</span><span class="s">&quot;id&quot;</span><span class="o">,</span> <span class="n">FieldType</span><span class="o">.</span><span class="na">LONG</span><span class="o">);</span>
<span class="n">movieSchema</span><span class="o">.</span><span class="na">addField</span><span class="o">(</span><span class="s">&quot;title&quot;</span><span class="o">,</span> <span class="n">FieldType</span><span class="o">.</span><span class="na">REFERENCE</span><span class="o">,</span> <span class="s">&quot;String&quot;</span><span class="o">);</span>
<span class="n">movieSchema</span><span class="o">.</span><span class="na">addField</span><span class="o">(</span><span class="s">&quot;releaseYear&quot;</span><span class="o">,</span> <span class="n">FieldType</span><span class="o">.</span><span class="na">INT</span><span class="o">);</span>

<span class="n">HollowObjectTypeWriteState</span> <span class="n">movieState</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowObjectTypeWriteState</span><span class="o">(</span><span class="n">movieSchema</span><span class="o">);</span>

<span class="n">writeEngine</span><span class="o">.</span><span class="na">addTypeState</span><span class="o">(</span><span class="n">movieState</span><span class="o">);</span>
</pre></div>


<p>Once we’ve initialized our type states, we can add data into our state engine using HollowWriteRecords:</p>
<div class="codehilite"><pre><span></span><span class="n">HollowObjectSchema</span> <span class="n">stringSchema</span> <span class="o">=</span> <span class="c1">/// the String schema</span>
<span class="n">HollowObjectSchema</span> <span class="n">movieSchema</span> <span class="o">=</span> <span class="c1">/// the Movie schema</span>

<span class="n">HollowObjectWriteRecord</span> <span class="n">titleRec</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowObjectWriteRecord</span><span class="o">(</span><span class="n">stringSchema</span><span class="o">);</span>
<span class="n">HollowObjectWriteRecord</span> <span class="n">movieRec</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowObjectWriteRecord</span><span class="o">(</span><span class="n">movieSchema</span><span class="o">);</span>

<span class="n">titleRec</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="s">&quot;value&quot;</span><span class="o">,</span> <span class="s">&quot;The Matrix&quot;</span><span class="o">);</span>

<span class="kt">int</span> <span class="n">titleOrdinal</span> <span class="o">=</span> <span class="n">writeEngine</span><span class="o">.</span><span class="na">addObject</span><span class="o">(</span><span class="s">&quot;String&quot;</span><span class="o">,</span> <span class="n">titleRec</span><span class="o">);</span>

<span class="n">movieRec</span><span class="o">.</span><span class="na">setLong</span><span class="o">(</span><span class="s">&quot;id&quot;</span><span class="o">,</span> <span class="mi">1</span><span class="o">);</span>
<span class="n">movieRec</span><span class="o">.</span><span class="na">setReference</span><span class="o">(</span><span class="s">&quot;title&quot;</span><span class="o">,</span> <span class="n">titleOrdinal</span><span class="o">);</span>
<span class="n">movieRec</span><span class="o">.</span><span class="na">setInt</span><span class="o">(</span><span class="s">&quot;releaseYear&quot;</span><span class="o">,</span> <span class="mi">1999</span><span class="o">);</span>

<span class="n">writeEngine</span><span class="o">.</span><span class="na">addObject</span><span class="o">(</span><span class="s">&quot;Movie&quot;</span><span class="o">,</span> <span class="n">movieRec</span><span class="o">);</span>
</pre></div>


<p>Note that referenced records must be added prior to referencing records in order to obtain the referenced ordinals.</p>
<div class="admonition tip">
<p class="admonition-title">Reusing HollowWriteRecords</p>
<p><code>HollowWriteRecord</code>s can be reused -- just be sure to call <code>reset()</code> before populating data from the next record.</p>
</div>
<p>Each schema type has its own <code>HollowTypeWriteState</code> and <code>HollowWriteRecord</code> implementation:</p>
<div class="codehilite"><pre><span></span><span class="n">HollowObjectSchema</span> <span class="n">objectSchema</span> <span class="o">=</span> <span class="c1">/// an Object schema</span>
<span class="n">HollowListSchema</span> <span class="n">listSchema</span> <span class="o">=</span> <span class="c1">/// a List schema</span>
<span class="n">HollowSetSchema</span> <span class="n">setSchema</span> <span class="o">=</span> <span class="c1">/// a Set schema</span>
<span class="n">HollowMapSchema</span> <span class="n">mapSchema</span> <span class="o">=</span> <span class="c1">/// a Map schema</span>

<span class="n">HollowObjectTypeWriteState</span> <span class="n">objectTypeState</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowObjectTypeWriteState</span><span class="o">(</span><span class="n">objectSchema</span><span class="o">);</span>
<span class="n">HollowListTypeWriteState</span> <span class="n">listTypeState</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowListTypeWriteState</span><span class="o">(</span><span class="n">listSchema</span><span class="o">);</span>
<span class="n">HollowSetTypeWriteState</span> <span class="n">setTypeState</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowSetTypeWriteState</span><span class="o">(</span><span class="n">setSchema</span><span class="o">);</span>
<span class="n">HollowMapTypeWritestate</span> <span class="n">mapTypeState</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowMapTypeWriteState</span><span class="o">(</span><span class="n">mapSchema</span><span class="o">);</span>

<span class="n">HollowObjectWriteRecord</span> <span class="n">objectRec</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowObjectWriteRecord</span><span class="o">(</span><span class="n">objectSchema</span><span class="o">);</span>
<span class="n">HollowListWriteRecord</span> <span class="n">listRec</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowListWriteRecord</span><span class="o">();</span>
<span class="n">HollowSetWriteRecord</span> <span class="n">setRec</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowSetWriteRecord</span><span class="o">();</span>
<span class="n">HollowMapWriteRecord</span> <span class="n">mapRec</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowMapWriteRecord</span><span class="o">();</span>
</pre></div>


<p>Using this API, it is possible to create a generic data ingestion mechanism from <em>any</em> type of input source. </p>
<h1 id="determining-populated-ordinals">Determining Populated Ordinals</h1>
<p>Many lower-level operations require knowledge of the currently populated ordinals (i.e. those which are not holes), or knowledge of ordinals which were populated in state prior to the last delta application.  We can determine this from any <em>type state</em> in a <code>HollowReadStateEngine</code>.  Both of these are useful, for example, if consumers wish to inspect exactly what has changed.</p>
<p>Each <code>HollowTypeReadState</code> underneath a <code>HollowReadStateEngine</code> contains the methods <code>getPopulatedOrdinals()</code> and <code>getPreviousOrdinals()</code>.  Each of these methods returns a <code>java.util.BitSet</code>.  The contents of returned <code>BitSet</code>s may be inspected, but should never be modified.</p>
<h1 id="caching">Caching</h1>
<p>Although a lot of effort has gone into minimizing the cost to read Hollow data, there is still inevitably a performance difference between accessing a field in a POJO and accessing a field in Hollow.  In general, this will not be a performance bottleneck, but in some rare cases the performance of tight inner loops may suffer on consumers.  </p>
<p>When there is a type with a low cardinality, we can instantiate and cache a POJO implementation for each ordinal, which can be used by consumers in tight inner loops.  This is accomplished by simply passing a <code>Set&lt;String&gt;</code> as the second constructor argument when instantiating a custom-generated Hollow API.  The elements in the Set should be the types to cache.</p>
<div class="admonition danger">
<p class="admonition-title">Avoid Premature Optimization</p>
<p>Caching should be used judiciously.  In all but the tightest of loops, caching will be unnecessary, and can even be detrimental to performance for types with a large cardinality.</p>
</div>
<h1 id="hollow-heap-effects">Hollow Heap Effects</h1>
<h2 id="double-snapshots">Double Snapshots</h2>
<p>At times, a new state may be produced to which there is no available delta from the previous state.  When this <em>broken delta chain</em> scenario occurs, consumers will by default attempt to load a snapshot to the latest state.  If a consumer loads a snapshot when it currently has a state loaded for the same dataset, we call this a <em>double snapshot</em>.  Double snapshots result in a doubling of the heap usage of your dataset.  This is because Hollow assumes that consumers may be actively using the current state, and it therefore must retain the current state to provide data while the next state is loaded.  Only after the next state is fully loaded can the old state be dropped.</p>
<p>If using the <a href="../producer-consumer/#consumer-framework"><code>Hollow Consumer</code></a>, you can configure consumers to never attempt a double snapshot.  This is accomplished with a custom <code>DoubleSnapshotConfig</code>.  In this case, you should check for 'stuck' clients in a <code>RefreshListener</code>, so that you may take the appropriate operational action.</p>
<p>If a dataset is large, double snapshots should be avoided for performance reasons.  Double snapshots can be entirely avoided by <a href="../producer-consumer/#restoring-at-startup">restoring</a> a <code>HollowWriteStateEngine</code> at producer initialization time, and, if necessary, using the <a href="../tooling/#patching"><code>HollowStateDeltaPatcher</code></a> to operationally fill lost or missing deltas in the event an unforeseen issue occurs.  </p>
<h2 id="type-sharding">Type Sharding</h2>
<p>During a delta transition each individual record type builds the entire next state of the type in memory while the current state is retained to answer requests.  This means that the memory pool Hollow reserves needs to be large enough to compose an extra copy of the largest type.  This is a miniaturized version of the <a href="./#double-snapshots">double snapshot</a> problem.</p>
<p>To address this problem, large types can be transparently sharded into smaller individual chunks, each of which updates independently.  The effect of this feature is that Hollow only needs to retain a large enough memory pool to update the largest <em>chunk</em> across all types.</p>
<p>Type sharding can be specified in two ways:  </p>
<ul>
<li>The recommended way is to specify a target max type shard size via a call to <code>setTargetMaxTypeShardSize(long bytes)</code> on a <code>HollowWriteStateEngine</code> prior to writing the first snapshot.  With this call, the number of shards will be automatically calculated based on the target excess memory pool size.</li>
<li>Additionally, the number of shards for a type can be explicitly specified by annotating a POJO with the <code>@HollowShardLargeType</code> annotation when using the <a href="../data-ingestion/#hollowobjectmapper"><code>HollowObjectMapper</code></a> for data ingestion.  This can be useful if rapid growth is anticipated in a type.</li>
</ul>
<p>Within a continuous delta chain, the type sharding configuration cannot be changed.  When a producer <a href="../producer-consumer/#restoring-at-startup">restores</a> the previously produced state at startup, then the restored <code>HollowWriteStateEngine</code> will always retain the sharding configuration of the prior state rather than recalculating based on the current size of each type.  Consequently, if the changes in a dataset over time results in a type sharding configuration which is highly suboptimal, it is recommended to start a new delta chain, which may require a double snapshot on all consumers, a simultaneous restart of all consumers, or a new <a href="../producer-consumer/#blob-namespaces">blob namespace</a> to which consumers can migrate over a period of time.</p>
<div class="admonition warning">
<p class="admonition-title">Backwards Compatibility</p>
<p>Type sharding is new in v2.1.0.  Consumers can read blobs produced by producers v2.1.0 and later <em>as long as type sharding is disabled</em>. 
If you are sure that all consumers are using v2.1.0 or later, it is safe to turn on type sharding.</p>
<p>In order to avoid causing issues for early adopters, the default target max type shard size is currently set to <code>Long.MAX_VALUE</code>.  At a later time, 
this default will be changed to 25MB.</p>
</div>
<h2 id="object-longevity">Object Longevity</h2>
<p>A Hollow object returned from a generated API contains a reference to the Hollow data store, and an ordinal.  For this reason, if a reference to a Hollow object is retained by the consumer for an extended period of time, and the underlying record changes unexpected results may begin to be returned from these references.  We call Hollow objects which were obtained from a no longer current state stale references.</p>
<p>It is best practice to <strong>never</strong> cache Hollow objects.  However, if it somehow <em>cannot</em> be guaranteed that Hollow Objects will never be cached at the consumer, and guaranteed protection against accidentally cached objects is necessary, then <em>object longevity</em> can be enabled.</p>
<p>With object longevity, Hollow objects will, after an update, be backed by a reserved copy of the data at the time the reference was created.  This guarantees that even if a reference is held for a long time, it will continue to return the same data when interrogated.</p>
<p>When object longevity is defined, Two durations are defined: </p>
<ul>
<li>a grace period, and </li>
<li>a usage detection period.  </li>
</ul>
<p>The grace period is defined by its duration, in milliseconds, after a reference becomes stale.  During the grace period, usage of stale references is acceptable.  The usage detection period is defined by its duration, in milliseconds, after the grace period has expired.  During the usage detection period, usage of stale references is unexpected, but will not result in failed interrogations of Hollow objects.  After the usage detection period expires, data will be dropped if no usage was detected in the usage detection period.  If stale references are interrogated <em>after</em> their backing data is dropped, then Exceptions will be thrown.</p>
<p>The <code>ObjectLongevityConfig</code>, injected into the <code>HollowConsumer</code> constructor, contains a few methods which are used to configure object longevity behavior:</p>
<ul>
<li><code>boolean enableLongLivedObjectSupport()</code>: Whether or not object longevity is enabled.</li>
<li><code>long gracePeriodMillis()</code>: If object longevity is enabled, this returns the number of milliseconds before the usage of stale objects gets flagged.</li>
<li><code>long usageDetectionPeriodMillis()</code>: If long-lived object support is enabled, this defines the number of milliseconds, after the grace period, during which data is still available in stale references, but usage will be flagged.</li>
<li><code>boolean dropDataAutomatically()</code>: Returns whether or not to drop data behind stale references after the grace period + usage detection period has elapsed, as long as no usage was detected during the usage detection period.  This can be used to avoid memory leaks when long lived object support is enabled and stale references are cached, but unused.</li>
<li><code>boolean forceDropData()</code>: Returns whether or not to drop data behind stale references after the grace period + usage detection period has elapsed, even if usage was detected during the usage detection period.  This can be used to avoid memory leaks when long lived object support is enabled and stale references are cached and used.</li>
</ul>
<p>Your implementation of the <code>ObjectLongevityConfig</code> may be backed by a dynamic configuration and safely change on live running consumers.  For example, <code>forceDropData()</code> may be operationally useful for boxes that are exhibiting memory leaks due to non-critical cached Hollow objects.</p>
<div class="admonition hint">
<p class="admonition-title">How It Works</p>
<p>When enabled, object longevity is achieved using the <code>HollowHistory</code> data structure, which results in a minimal heap overhead. </p>
</div>
<h2 id="memory-pooling">Memory Pooling</h2>
<p>Hollow pools and reuses memory to minimize GC effects while updating data.  This pool of memory is kept arrays on the heap.  Each array in the pool has a fixed length.  When a long array or a byte array is required in Hollow, it will stitch together pooled array segments as a <code>SegmentedByteArray</code> or <code>SegmentedLongArray</code>.  These classes encapsulate the details of treating segmented arrays as contiguous ranges of values.</p>
<h1 id="delta-based-producer-input">Delta-Based Producer Input</h1>
<p>The <a href="../getting-started/">Getting Started</a> section of this documentation describes a producer which every so often reads the <em>entire dataset</em> from some source of truth, re-adds all records to a <code>HollowWriteStateEngine</code>, then produces a delta based on the automatically discovered differences in the dataset since the prior cycle.  It is possible, however, that a producer may <em>receive</em> an incoming stream of events which directly indicate the changes to a dataset, obviating the need to scan through the entire source of truth and re-add the entire dataset on each cycle.</p>
<p>If desired, a <code>HollowWriteStateEngine</code>’s state can be explicitly modified, rather than recreated, each cycle.  We start such a cycle by re-adding all of the records from the previous cycle to the state engine:</p>
<div class="codehilite"><pre><span></span><span class="n">HollowWriteStateEngine</span> <span class="n">writeEngine</span> <span class="o">=</span> <span class="c1">/// the state engine</span>

<span class="n">writeEngine</span><span class="o">.</span><span class="na">prepareForNextCycle</span><span class="o">();</span>
<span class="n">writeEngine</span><span class="o">.</span><span class="na">addAllObjectsFromPreviousCycle</span><span class="o">();</span>
</pre></div>


<p>We’ll also need an indexed <code>HollowReadStateEngine</code>, which is updated in lock-step with the <code>HollowWriteStateEngine</code>.  The index can be used to retrieve the ordinals of records to be replaced.  These ordinals can be removed from the <code>HollowWriteStateEngine</code>:</p>
<div class="codehilite"><pre><span></span><span class="n">HollowObjectMapper</span> <span class="n">mapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HollowObjectMapper</span><span class="o">(</span><span class="n">writeEngine</span><span class="o">);</span>
<span class="n">HollowPrimaryKeyIndex</span> <span class="n">idx</span> <span class="o">=</span> 
                       <span class="k">new</span> <span class="n">HollowPrimaryKeyIndex</span><span class="o">(</span><span class="n">readEngine</span><span class="o">,</span> <span class="s">&quot;Movie&quot;</span><span class="o">,</span> <span class="s">&quot;id&quot;</span><span class="o">);</span>

<span class="n">HollowTypeWriteState</span> <span class="n">movieTypeState</span> <span class="o">=</span> <span class="n">writeEngine</span><span class="o">.</span><span class="na">getTypeState</span><span class="o">(</span><span class="s">&quot;Movie&quot;</span><span class="o">);</span>

<span class="n">List</span><span class="o">&lt;</span><span class="n">MovieUpdateEvent</span><span class="o">&gt;</span> <span class="n">eventBatch</span> <span class="o">=</span> <span class="c1">/// a batch of events</span>

<span class="k">for</span><span class="o">(</span><span class="n">MovieUpdateEvent</span> <span class="n">event</span> <span class="o">:</span> <span class="n">eventBatch</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">oldOrdinal</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="na">getMatchingOrdinal</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getMovie</span><span class="o">().</span><span class="na">getId</span><span class="o">());</span>
    <span class="n">movieTypeState</span><span class="o">.</span><span class="na">removeOrdinalFromThisCycle</span><span class="o">(</span><span class="n">oldOrdinal</span><span class="o">);</span>
    <span class="n">mapper</span><span class="o">.</span><span class="na">addObject</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getMovie</span><span class="o">());</span>
<span class="o">}</span>
</pre></div>


<div class="admonition danger">
<p class="admonition-title">Watch out for Duplicates</p>
<p>Be careful, this process assumes that no two events will have the same movie ID in the same cycle.  You'll want to dedup the <code>eventBatch</code>.</p>
</div>
<p>This process may leave orphaned records around, since the call to <code>removeOrdinalFromThisCycle()</code> doesn’t remove any referenced records.  To solve this, the <a href="../tooling/#transitive-set-traverser"><code>TransitiveSetTraverser</code></a> can be used:</p>
<div class="codehilite"><pre><span></span><span class="n">List</span><span class="o">&lt;</span><span class="n">MovieUpdateEvent</span><span class="o">&gt;</span> <span class="n">eventBatch</span> <span class="o">=</span> <span class="c1">/// a batch of events</span>

<span class="c1">/// find the Movie ordinals to remove</span>
<span class="n">BitSet</span> <span class="n">removedMovieOrdinals</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BitSet</span><span class="o">();</span>
<span class="k">for</span><span class="o">(</span><span class="n">MovieUpdateEvent</span> <span class="n">event</span> <span class="o">:</span> <span class="n">eventBatch</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">oldOrdinal</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="na">getMatchingOrdinal</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getMovie</span><span class="o">().</span><span class="na">getId</span><span class="o">());</span>
    <span class="n">removedMovieOrdinals</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">oldOrdinal</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">/// initially the removal selection includes just Movies</span>
<span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">BitSet</span><span class="o">&gt;</span> <span class="n">removeRecords</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">removeRecords</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">&quot;Movie&quot;</span><span class="o">,</span> <span class="n">removedMovieOrdinals</span><span class="o">);</span>

<span class="c1">/// expand the selection to include any records referenced by selected Movies</span>
<span class="n">TransitiveSetTraverser</span><span class="o">.</span><span class="na">addTransitiveMatches</span><span class="o">(</span><span class="n">readEngine</span><span class="o">,</span> <span class="n">removeRecords</span><span class="o">);</span>
<span class="c1">/// but don&#39;t include records which are also referenced by unselected movies</span>
<span class="n">TransitiveSetTraverser</span><span class="o">.</span><span class="na">removeReferencedOutsideClosure</span><span class="o">(</span><span class="n">readEngine</span><span class="o">,</span> <span class="n">removeRecords</span><span class="o">);</span>

<span class="c1">/// remove everything in the selection</span>
<span class="k">for</span><span class="o">(</span><span class="n">Map</span><span class="o">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">BitSet</span><span class="o">&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">removeRecords</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">HollowTypeWriteState</span> <span class="n">typeState</span> <span class="o">=</span> <span class="n">writeEngine</span><span class="o">.</span><span class="na">getTypeState</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getKey</span><span class="o">());</span>
    <span class="kt">int</span> <span class="n">removeOrdinal</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">nextSetBit</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
    <span class="k">while</span><span class="o">(</span><span class="n">removeOrdinal</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">typeState</span><span class="o">.</span><span class="na">removeOrdinalFromThisCycle</span><span class="o">(</span><span class="n">removeOrdinal</span><span class="o">);</span>
        <span class="n">removeOrdinal</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="na">getValue</span><span class="o">().</span><span class="na">nextSetBit</span><span class="o">(</span><span class="n">removeOrdinal</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>


<p>In the above code, each of the <code>Movie</code> ordinals to be replaced are added to a <code>BitSet</code>.  Then, the <code>TransitiveSetTraverser</code> is used to expand the collection of selected records by adding any records referenced by the selected <code>Movies</code>.  Then, the <code>TransitiveSetTraverser</code> is again used to deselect any child records which are also referenced by other Movies which were not selected for removal.  Finally, the selection is actually removed from the <code>HollowWriteStateEngine</code>.</p>
<h1 id="in-memory-data-layout">In-Memory Data Layout</h1>
<p>Each record in Hollow begins with a fixed-length number of bits.  At the lowest level, these bits are held in long arrays using the class <code>FixedLengthElementArray</code>.  This class allows for storage and retrieval of fixed-length data in a range of bits.  For example, if a <code>FixedLengthElementArray</code> was queried for the 6-bit value starting at bit 7 in the following example range of bits:</p>
<p><img alt="Bit String" src="../img/memlayout-bitstring.png" /></p>
<p>The value <code>100100</code> in binary, or <code>36</code> in base 10, would be returned.</p>
<h3 id="object-layout">Object Layout</h3>
<p>An <code>OBJECT</code> record is a fixed set of strongly typed fields.  Each field is represented by a fixed-length number of bits.  Each record is represented by a fixed length number of bits equal to the sum of the bits required to represent each fields.  For each type, all fields of all records are packed into a single <code>FixedLengthElementArray</code>.  No bookkeeping data structures are required to locate a record -- the start bit for each record can is located by simply multiplying the number of bits per record times the record’s ordinal.</p>
<p><img alt="Object Layout" src="../img/memlayout-object.png" /></p>
<p>The number of bits used to represent a field which is one of the types (<code>INT</code>, <code>LONG</code>, <code>REFERENCE</code>) is exactly equal to the number of bits required to represent the maximum value contained in the field across all records.  The values for <code>INT</code> and <code>LONG</code> fields are represented using zig-zag encoding, so that smaller absolute values require fewer bits.  The values for <code>REFERENCE</code> fields are encoded as the referenced record’s ordinal, which along with the referenced type (from the schema) is sufficient to identify and locate the referenced record.</p>
<p>32 bits are used to represent a <code>FLOAT</code>, and 64 bits are used to represent a <code>DOUBLE</code>.</p>
<p><code>STRING</code> and <code>BYTES</code> fields each get a separate byte array, into which the values for all records are packed.  The fixed-length value in these fields are offsets into the field’s byte array where the record’s value ends.  In order to determine the begin byte for the record with ordinal n, the offset encoded into the record with ordinal (n-1) is read.  The number of fixed length bits used to represent the offsets is exactly equal to the number of number of bits required to represent the maximum offset, plus one.</p>
<p>Each field type may be assigned a null value.  For <code>INT</code>, <code>LONG</code>, and <code>REFERENCE</code> fields, null is encoded as a value with all ones.  For <code>FLOAT</code> and <code>DOUBLE</code> fields, null is encoded as special bit sequences.  For <code>STRING</code> and <code>BYTES</code> fields, null is encoded by setting a designated null bit at the beginning of each field, followed by the end offset of the last populated value for that field.</p>
<h3 id="list-layout">List Layout</h3>
<p>A <code>LIST</code> is an ordered collection of records of a specific type.  <code>LIST</code> types are represented with two FixedLengthElementArrays.  We can refer to these arrays as the <em>offset array</em> and the <em>element array</em>.</p>
<p>Each <code>LIST</code> type contains a single <em>element array</em> into which the references to elements for all records are packed.  References are encoded as the ordinals of the element records, which is sufficient to identify and locate the record.  Each reference is represented using a fixed number of bits equal to the number of bits required to represent the maximum referenced ordinal across all records.  Each record is represented with a contiguous range of elements in the <em>element array</em>.  </p>
<p>The <em>offset array</em> contains fixed-length offsets into the element array where the record’s elements end.  In order to determine the begin element for the record with ordinal n, the end value for the element (n-1) is read.  </p>
<p><img alt="List Layout" src="../img/memlayout-list.png" /></p>
<p>Elements in a <code>LIST</code> record may not be null.</p>
<h3 id="set-layout">Set Layout</h3>
<p>A <code>SET</code> is an unordered collection of records of a specific type.  The records for <code>SET</code> elements are hashed into an open-addressed hash table.  <code>SET</code> types are represented with two <code>FixedLengthElementArrays</code>.  We can refer to these arrays as the <em>offset array</em> and the <em>bucket array</em>.</p>
<p>Each <code>SET</code> element contains a single <em>bucket array</em> into which the references to elements for all records are packed.  Each record is represented with a contiguous range of buckets in the <em>bucket array</em>.  The range of buckets for each record will contain an open-addressed hash table, with a linear probing hash collision resolution strategy.  The number of buckets for each record will be a power of two, and will be large enough such that all elements for the record will fit into those buckets with a load factor no greater than 70%.  Each bucket is represented using a fixed number of bits equal to the number of bits required to represent the maximum referenced ordinal across all records.  A populated bucket is encoded as the ordinal of the referenced record in that bucket.  To represent empty buckets, a sentinel value equal to all ones in binary is reserved.</p>
<p>The <em>offset array</em> contains two fixed-length fields per record:  the size of the set, and the offset to the bucket where the record’s data ends.  Each of these fields is encoded using a fixed number of bits equal to the number of bits required to represent the field’s maximum value across all records.</p>
<p><img alt="Set Layout" src="../img/memlayout-set.png" /></p>
<p>Elements in a <code>SET</code> record may not be null.</p>
<h3 id="map-layout">Map Layout</h3>
<p>A <code>MAP</code> is an unordered collection of key/value pairs, where each key is a specific type, and each value type is a specific type.  The records for MAP elements are hashed into an open-addressed hash table.  <code>MAP</code> types are represented with two <code>FixedLengthElementArrays</code>.  We can refer to these arrays as the <em>offset array</em> and the <em>bucket array</em>.</p>
<p>Each <code>MAP</code> type contains a single bucket array into which the references to keys and values for all records are packed.  Each record is represented with a contiguous range of buckets in the <em>bucket array</em>.  The range of buckets for each record will contain an open-addressed hash table, with a linear probing hash collision resolution strategy.  The number of buckets for each record will be a power of two, and will be large enough such that all key/value pairs for the record will fit into those buckets with a load factor no greater than 70%.  Each bucket is represented using a fixed number of bits equal to the number of bits required to represent the maximum referenced key ordinal, plus the number of bits required to represent the maximum referenced value ordinal.  A populated bucket contains two fixed length fields: the first field contains the ordinal of the referenced key, and the second field contains the ordinal of the referenced value.  Empty buckets are represented with a key field containing a reserved sentinel value equal to all ones in binary.</p>
<p>The <em>offset array</em> contains two fixed-length fields per record:  the size of the map, and the offset to the bucket where the record’s data ends.  Each of these fields is encoded using a fixed number of bits equal to the number of bits required to represent the field’s maximum value across all records.</p>
<p><img alt="Map Layout" src="../img/memlayout-map.png" /></p>
<p>A <code>MAP</code> cannot contain null keys or values.</p>
<h3 id="primary-key-index-layout">Primary Key Index Layout</h3>
<p>A primary key index is a single <code>FixedLengthElementArray</code>, which represents an open-addressed hash table of pointers to records of the given type.  The hash of each record is derived based on the fields designated in the primary key.  Each bucket in the hash table is represented using a fixed number of bits equal to the number of bits required to represent the maximum ordinal of the indexed type.  A populated bucket is encoded as the ordinal of the referenced record in that bucket.  To represent empty buckets, a sentinel value equal to all ones in binary is reserved.</p>
<p>When queried with a key, the index will hash the key, look in the corresponding bucket to find the ordinal of a record which also hashes to this key, then compare the referenced record’s key to the query.  When a matching record is found, the ordinal at that bucket is returned as the match.  Collisions are resolved with linear probing.  If after linear probing an empty bucket is encountered, no such record exists in the dataset.</p>
<h3 id="hash-index-layout">Hash Index Layout</h3>
<p>A hash index is uses two <code>FixedLengthElementArrays</code>.  These arrays can be referred to as the <em>match array</em> and the <em>select array</em>.  The <em>match array</em> is an open-addressed hash table and contains buckets.  Like a primary key index, the match array does not re-encode the values of keys.  Instead, it retains pointers to existing records which may be used to retrieve the hashed keys.</p>
<p>Unlike a primary key index, it may not be sufficient to retain a single pointer to the indexed type and extract the hashed key from that record -- each record in a hash index may match multiple keys.  Instead, we retain 1-n pointers.  Each pointer will indicate a record through which one or more of the key fields may be unambiguously retrieved.  If multiple key fields may be unambiguously traversed to via a single type, then only a single pointer for the field group will be retained per bucket.  </p>
<p>Consider a scenario in which a hash index is used to index Movies by the nationalities and birth year of actors.  For the key <code>[“British”, 1972]</code>, the corresponding entry in the match array may contain a pointer to the <code>Actor</code> record for Idris Elba.  Although the record points to a specific <code>Actor</code>, the matching records for this entry will contain movies starring any British Actor born in 1972.</p>
<p>Each pointer field in the match array bucket references a specific type, and is encoded as the ordinal to which the bucket refers.  Each is represented using a fixed number of bits equal to the maximum ordinal in the referenced type.</p>
<p>In addition to pointers which allow us to look up the matching key, each bucket in the <em>match array</em> includes the number of matching records, and an offset into the <em>select array</em>.  The <em>select array</em> contains lists of ordinals to matching records.</p>
<p>When queried with a key, the index will hash the key, then look to the corresponding bucket in the <em>match array</em>.  The match pointers are used to compare the queried key with the matching key.  If a match is found, then the corresponding entries in the select array are returned as a <code>HollowHashIndexResult</code>.  Collisions are resolved with linear probing.  If after linear probing an empty bucket is encountered in the match array, no such record exists in the dataset.</p>
                
                  
                
              
              
                
              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../data-ingestion/" title="Data Ingestion" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Data Ingestion
              </span>
            </div>
          </a>
        
        
          <a href="../glossary/" title="Glossary" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Glossary
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="http://www.mkdocs.org" title="MkDocs">MkDocs</a>
        and
        <a href="http://squidfunk.github.io/mkdocs-material/" title="Material for MkDocs">
          Material for MkDocs</a>
      </div>
      
        
  <div class="md-footer-social">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    
      <a href="https://github.com/Netflix/hollow" class="md-footer-social__link fa fa-github"></a>
    
      <a href="https://gitter.im/Netflix/hollow" class="md-footer-social__link fa fa-gitter"></a>
    
  </div>

      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application-f3ab9e5ff8.js"></script>
      
      
      <script>app.initialize({url:{base:".."}})</script>
      
    
    
      
    
  </body>
</html>